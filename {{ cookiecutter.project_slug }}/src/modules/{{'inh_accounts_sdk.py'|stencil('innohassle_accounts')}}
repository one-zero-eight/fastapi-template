import datetime
import time

import httpx
from authlib.jose import JsonWebKey, JWTClaims, KeySet, jwt
from authlib.jose.errors import JoseError
from pydantic import BaseModel

from src.config import settings


class UserInfoFromSSO(BaseModel):
    email: str
    name: str | None = None

    issued_at: datetime.datetime | None = None
    is_student: bool = False
    is_staff: bool = False
    group: str | None = None


class TelegramWidgetData(BaseModel):
    id: int
    auth_date: int
    first_name: str
    last_name: str | None = None
    username: str | None = None
    photo_url: str | None = None


class UserSchema(BaseModel):
    telegram: TelegramWidgetData | None
    innopolis_sso: UserInfoFromSSO | None


class UserTokenData(BaseModel):
    innohassle_id: str
    "InNoHassle Accounts ID"
    email: str | None = None
    "Innopolis email (@innopolis.university or @innopolis.ru)"
    telegram_id: int | None = None
    "User's Telegram ID connected to InNoHassle Accounts"


class InNoHassleAccounts:
    api_url: str
    api_jwt_token: str
    PUBLIC_KID = "public"
    key_set: KeySet

    def __init__(self, api_url: str, api_jwt_token: str):
        self.api_url = api_url
        self.api_jwt_token = api_jwt_token

    async def update_key_set(self):
        self.key_set = await self.get_key_set()

    def get_public_key(self) -> JsonWebKey:
        if self.key_set is None:
            raise RuntimeError("Key set should be initialized by `update_key_set`")
        return self.key_set.find_by_kid(self.PUBLIC_KID)

    async def get_key_set(self) -> KeySet:
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{self.api_url}/.well-known/jwks.json")
            response.raise_for_status()
            jwks_json = response.json()
            return JsonWebKey.import_key_set(jwks_json)

    def decode_token(self, token: str) -> UserTokenData | None:
        """
        Decode generated by InnoHassle Accounts user JWT token and return user data.
        If token is invalid, return None.
        """
        try:
            payload = self._get_jwt_claims(token)
            innohassle_id: str = payload["uid"]
            email: str | None = payload.get("email")
            telegram_id: int | None = payload.get("telegram_id")
            return UserTokenData(
                innohassle_id=innohassle_id,
                email=email,
                telegram_id=telegram_id,
            )
        except JoseError:
            # logger.warning("Invalid token", exc_info=True)
            return None

    def get_authorized_client(self) -> httpx.AsyncClient:
        return httpx.AsyncClient(
            headers={"Authorization": f"Bearer {self.api_jwt_token}"},
            base_url=self.api_url,
        )

    def _get_jwt_claims(self, token: str) -> JWTClaims:
        now = time.time()
        pub_key = self.get_public_key()
        payload = jwt.decode(token, pub_key)
        payload.validate_exp(now, leeway=0)
        payload.validate_iat(now, leeway=0)
        return payload

    async def get_user(
        self,
        innohassle_id: str | None = None,
        email: str | None = None,
        telegram_id: int | None = None,
    ) -> UserSchema | None:
        """
        Get user by one of the provided identifiers.
        If multiple identifiers are provided, the first one that exists will be returned.
        """
        async with self.get_authorized_client() as client:
            urls = []
            if innohassle_id:
                urls.append(f"/users/by-id/{innohassle_id}")
            if email:
                urls.append(f"/users/by-innomail/{email}")
            if telegram_id:
                urls.append(f"/users/by-telegram-id/{telegram_id}")
            for url in urls:
                response = await client.get(url)
                try:
                    response.raise_for_status()
                    return UserSchema.model_validate(response.json())
                except httpx.HTTPStatusError as e:
                    if e.response.status_code == 404:
                        continue
                    raise e
            return None


inh_accounts: InNoHassleAccounts = InNoHassleAccounts(
    api_url=settings.accounts.api_url,
    api_jwt_token=settings.accounts.api_jwt_token.get_secret_value(),
)
